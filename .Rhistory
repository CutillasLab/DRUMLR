# import markers
df_m <- "phospho_solid_markers"
}
}else if(input_type=="protein"){
df_val <- DRUMLR:::DRUMLprot[,info$cell_names]
if(model_type=="aml"){
# File were model names and paths are located:
file.models <- read.csv(
"https://www.dropbox.com/s/sircuo6tveuox0g/Paths%20to%20models%20from%20proteomics%20dist%20aml.csv?dl=1")
# import markers
df_m <- "prot_aml_markers"
}else if(solid.or.aml=="solid"){
# File were model names and paths are located:
file.models <- read.csv("https://www.dropbox.com/s/hh96xwxyunsfx8h/Paths%20to%20models%20from%20proteomics%20dist%20solid.csv?dl=1")
# import markers
df_m <- "prot_solid_markers"
}
}else if(input_type=="RNA"){
df_val <- DRUMLR:::DRUMLrna[,info$cell_names]
if (model_type=="aml"){
# File were model names and paths are located:
file.models <- read.csv("https://www.dropbox.com/s/qao4dvr2ny5d6q0/Paths%20to%20models%20from%20rna%20dist%20aml.csv?dl=1")
# import markers
df_m <- "rna_aml_markers"
}else if(solid.or.aml=="solid"){
# File were model names and paths are located:
file.models <- read.csv("https://www.dropbox.com/s/0vb5xco6vwt90v1/Paths%20to%20models%20from%20rna%20dist%20solid.csv?dl=1")
# import markers
df_m <- "rna_solid_markers"
}
}
############################################################################################
#test compatibility
#remove missing Variables from dataset
df_val <- df_val[rownames(df_val) %in%rownames(df_input),]
#get distances with missing variables
df_val <- DrugMarkerEnrichment(df=df_val, scale = T, marker_database = df_m)[[1]] %>% t()
df_val <- df_val[[1]]
#internal prediction function for caret models
.PredictModelCaret <- function(file.models,model.name,drug, df_input){
rmse.of.model.per.drug <- file.models[file.models$drug== drug & tolower(file.models$model)==model.name ,"val.rmse"][1]
if(length(rmse.of.model.per.drug)>0|is.na(rmse.of.model.per.drug)==F){
myfile <- file.models[file.models$drug== drug & tolower(file.models$model)==model.name ,"paths"][1]
if(file.exists(myfile)){
mymodel <- readRDS(myfile)
tryCatch({out <- predict(mymodel,df_input)},error=function(e){})}
}else{out<- data.frame(rep(NA, each = nrow(df_input)))}
colnames(out)<- model.name
rownames(out) <- rownames(df_input)
return(out)
}
#internal prediction function for h2o models
.PredictModelh2o <- function(file.models,model.name,drug, df_input){
rmse.of.model.per.drug <- file.models[file.models$drug== drug & tolower(file.models$model)==model.name ,"val.rmse"][1]
if(length(rmse.of.model.per.drug)>0|!is.na(rmse.of.model.per.drug)){
myfile <- file.models[file.models$drug== drug & tolower(file.models$model)==model.name ,"paths"][1]
if(file.exists(myfile)){
mymodel <-h2o::h2o.loadModel(myfile)
tryCatch({df.predicted.aac.dl[drug,] <- t(as.data.frame(predict(mymodel,as.h2o(df.t))))},error=function(e){})}
}else{out<- data.frame(rep(NA, each = nrow(df_input)))}
colnames(out)<- model.name
rownames(out) <- rownames(df_input)
return(out)
}
# Predict for each ML algorithm if the RMSE is less than the cut-off value
df_pred <- foreach::foreach(i = drugs, combine = .rbind)%dopar%{
dl <- .PredictModelh2o(file.models = file.models,
df_input = df_input,
drug = i,
model.name = "dl")
nnet <- .PredictModelCaret(file.models = file.models,
df_input = df_input,
drug = i,
model.name = "nnet")
pcr <- .PredictModelCaret(file.models = file.models,
df_input = df_input,
drug = i,
model.name = "pcr")
pls <- .PredictModelCaret(file.models = file.models,
df_input = df_input,
drug = i,
model.name = "pls")
rf <- .PredictModelCaret(file.models = file.models,
df_input = df_input,
drug = i,
model.name = "rf")
svm <- .PredictModelCaret(file.models = file.models,
df_input = df_input,
drug = i,
model.name = "svm")
out<- data.frame("dl" = dl,
"nnet" = nnet,
"pcr" = pcr,
"pls" = pls,
"rf" = rf,
"svm" = svm)
#caluclate new error values for model dur to missing variables
out <- apply(out, MARGIN = 2, FUN = function(x){
rmse <- caret::RMSE(pred = x, obs = df_response, na.rm = T)
caret::R2(pred = x, obs = df_response, na.rm = T)
return(rmse)
})
}
return(df_pred)
}
#roxygen description
#' @name  predict.drug.sensitivity.based.on.distance.markers
#' @title  Make a heatmap of marker enrichment
#' @usage predict.drug.sensitivity.based.on.distance.markers(markers = GetMarkers("barasetib")$sensitive$.,inputdata = LoadData("PDBphos"),tissuefilter = "haematopoietic_and_lymphoid_tissue",metric = "aac", drug = "ABT-199")
#' @param predict.drug.sensitivity.based.on.distance.markers List of markers to filter the input data by
#' @param dataframe to use for the heatmap valuesdf.ppindex is phosphoproteomics, proteomics or transcriptomics data with rownames being identifiers
#' @param rmse.cutoff error cut off to define models as reliable
#' @param solid.or.aml which models to predict sensitvity
#' @param type "phospho","protein","RNA","ksea edges","reactome prot"
predict.drug.sensitivity.based.on.distance.markers <- function(df_distance,
df.ppindex,
rmse.cutoff=0.15,
solid.or.aml="aml",
model_type=c("phospho",
"protein",
"RNA"),
drugs){
if("tidyverse" %in% (.packages())==FALSE){library(dplyr)}
if("caret" %in% (.packages())==FALSE){library(caret)}
if("h2o" %in% (.packages())==FALSE){library(h2o)}
if("doParallel" %in% (.packages())==FALSE){library(doParallel)}
if("foreach" %in% (.packages())==FALSE){library(foreach)}
set.seed(123)
h2o.init()
if (input_type=="phospho"){
if (model_type=="aml"){
# File were model names and paths are located:
file.models <- read.csv(
"https://www.dropbox.com/s/1wgs4djqpvhx6sr/Paths%20to%20models%20from%20phospho%20dist%20aml.csv?dl=1")
# File where markers per drug are listed
df_m <- DRUMLR:::phospho_aml_markers %>% data.frame(stringsAsFactors = F, row.names = 1)
}else if(model_type=="solid"){
# File were model names and paths are located:
file.models <- read.csv(
"https://www.dropbox.com/s/zitaykih78g9osi/Paths%20to%20models%20from%20phospho%20dist%20solid.csv?dl=1")
# File where markers per drug are listed
df_m <- DRUMLR:::phospho_solid_markers %>% data.frame(stringsAsFactors = F, row.names = 1)    }
}else if(input_type=="protein"){
if(model_type=="aml"){
# File were model names and paths are located:
file.models <- read.csv(
"https://www.dropbox.com/s/sircuo6tveuox0g/Paths%20to%20models%20from%20proteomics%20dist%20aml.csv?dl=1")
# File where markers per drug are listed
df_m <- DRUMLR:::prot_aml_markers %>% data.frame(stringsAsFactors = F, row.names = 1)    }else if(solid.or.aml=="solid"){
# File were model names and paths are located:
file.models <- read.csv(
"https://www.dropbox.com/s/hh96xwxyunsfx8h/Paths%20to%20models%20from%20proteomics%20dist%20solid.csv?dl=1")
# File where markers per drug are listed
df_m <- DRUMLR:::prot_solid_markers %>% data.frame(stringsAsFactors = F, row.names = 1)    }
}else if(input_type=="RNA"){
if (model_type=="aml"){
# File were model names and paths are located:
file.models <- read.csv(
"https://www.dropbox.com/s/qao4dvr2ny5d6q0/Paths%20to%20models%20from%20rna%20dist%20aml.csv?dl=1")
# File where markers per drug are listed
df_m <- DRUMLR:::rna_aml_markers %>% data.frame(stringsAsFactors = F, row.names = 1)    }else if(solid.or.aml=="solid"){
# File were model names and paths are located:
file.models <- read.csv(
"https://www.dropbox.com/s/0vb5xco6vwt90v1/Paths%20to%20models%20from%20rna%20dist%20solid.csv?dl=1")
# File where markers per drug are listed
df_m <- DRUMLR:::rna_solid_markers %>% data.frame(stringsAsFactors = F, row.names = 1)
}
}
file.models$paths <- gsub("/","\\",file.models$paths, fixed=T)
file.models <- unique(file.models)
# transpose the marker data so that it is in the right format for predictions
df.tt <- data.frame(t(df_distance))
drugs <- unique(file.models$drug)
.PredictModelCaret <- function(file.models,model.name,drug, df_input){
rmse.of.model.per.drug <- file.models[file.models$drug== drug & tolower(file.models$model)==model.name ,"val.rmse"][1]
if(length(rmse.of.model.per.drug)>0|is.na(rmse.of.model.per.drug)==F|rmse.of.model.per.drug<rmse.cutoff){
myfile <- file.models[file.models$drug== drug & tolower(file.models$model)==model.name ,"paths"][1]
if(file.exists(myfile)){
mymodel <- readRDS(myfile)
tryCatch({out <- predict(mymodel,df_input)},error=function(e){})}
}else{out<- data.frame(rep(NA, each = nrow(df_input)))}
colnames(out)<- model.name
rownames(out) <- rownames(df_input)
return(out)
}
.PredictModelh2o <- function(file.models,model.name,drug, df_input){
rmse.of.model.per.drug <- file.models[file.models$drug== drug & tolower(file.models$model)==model.name ,"val.rmse"][1]
if(length(rmse.of.model.per.drug)>0|!is.na(rmse.of.model.per.drug)|rmse.of.model.per.drug<rmse.cutoff){
myfile <- file.models[file.models$drug== drug & tolower(file.models$model)==model.name ,"paths"][1]
if(file.exists(myfile)){
mymodel <-h2o::h2o.loadModel(myfile)
tryCatch({df.predicted.aac.dl[drug,] <- t(as.data.frame(predict(mymodel,as.h2o(df.t))))},error=function(e){})}
}else{out<- data.frame(rep(NA, each = nrow(df_input)))}
colnames(out)<- model.name
rownames(out) <- rownames(df_input)
return(out)
}
# Predict for each ML algorithm if the RMSE is less than the cut-off value
df_pred <- foreach::foreach(i = drugs, combine = .rbind)%dopar%{
dl <- .PredictModelh2o(file.models = file.models,
df_input = df_input,
drug = i,
model.name = "dl")
nnet <- .PredictModelCaret(file.models = file.models,
df_input = df_input,
drug = i,
model.name = "nnet")
pcr <- .PredictModelCaret(file.models = file.models,
df_input = df_input,
drug = i,
model.name = "pcr")
pls <- .PredictModelCaret(file.models = file.models,
df_input = df_input,
drug = i,
model.name = "pls")
rf <- .PredictModelCaret(file.models = file.models,
df_input = df_input,
drug = i,
model.name = "rf")
svm <- .PredictModelCaret(file.models = file.models,
df_input = df_input,
drug = i,
model.name = "svm")
out<- data.frame("drug" = drug,
"dl" = dl,
"nnet" = nnet,
"pcr" = pcr,
"pls" = pls,
"rf" = rf,
"svm" = svm)
}
return(list(distance.marker.data=df.distance.marker.data,
predicted.based.on.nnet=df.predicted.aac.nnet,
predicted.based.on.pls=df.predicted.aac.pls,
predicted.based.on.rf=df.predicted.aac.rf,
predicted.based.on.pcr=df.predicted.aac.pcr,
predicted.based.on.svm=df.predicted.aac.svm,
predicted.based.on.dl=df.predicted.aac.dl))
}
# roxygen description
#' @title A score of marker ratios
#' @name GetIntMarkerDB
#' @export GetIntMarkerDB
#' @usage  GetIntMarkerDB("aml_prot_markers")
#' @description draw in internal databases
#' @param database database to draw into environment
GetIntMarkerDB <- function(database){
if("dplyr" %in% (.packages())==FALSE){library(dplyr)}
if(database == "aml_phos_markers"){out <- DRUMLR:::aml_phos_markers %>% data.frame(row.names = 1, stringsAsFactors = F)
}else if(database == "all_phos_markers"){out <- DRUMLR:::all_phos_markers %>% data.frame(row.names = 1, stringsAsFactors = F)
}else if(database == "solid_phos_markers"){out <- DRUMLR:::solid_phos_markers %>% data.frame(row.names = 1, stringsAsFactors = F)
}else if(database == "aml_prot_markers"){out <- DRUMLR:::aml_prot_markers %>% data.frame(row.names = 1, stringsAsFactors = F)
}else if(database == "all_prot_markers"){out <- DRUMLR:::all_prot_markers %>% data.frame(row.names = 1, stringsAsFactors = F)
}else if(database == "solid_prot_markers"){out <- DRUMLR:::solid_prot_markers %>% data.frame(row.names = 1, stringsAsFactors = F)
}else if(database == "aml_rna_markers"){out <- DRUMLR:::aml_rna_markers %>% data.frame(row.names = 1, stringsAsFactors = F)
}else if(database == "all_rna_markers"){out <- DRUMLR:::all_rna_markers %>% data.frame(row.names = 1, stringsAsFactors = F)
}else if(database == "solid_rna_markers"){out <- DRUMLR:::solid_rna_markers %>% data.frame(row.names = 1, stringsAsFactors = F)}
out <- list("sensitive_markers" = out[,c("m_sens", "sensitive_markers")],
"resistant_markers" = out[,c("m_res", "resistant_markers")])
return(out)
}
#roxygen description
#' @name  inv_ecdf
#' @export inv_ecdf
#' @title  inv_ecdf
inv_ecdf <- function(f){
x <- environment(f)$x
y <- environment(f)$y
approxfun(y, x)
}
#roxygen description
#' @name  OptimiseMarkers
#' @export OptimiseMarkers
#' @title  Optimise marker set for machine learning
#' @usage OptimiseMarkers(EMSRoutput = EMSRout, drug = "ABT-119", df_response = df.aac, df_input = df.phos)
#' @param EMSRoutput output of GenerateEMSR function (get_limma must be False)
#' @param drug Drug which the markers will be generated for
#' @param df_response Dataframe with rownames as cell lines and drug responses
#' @param df_input = Input dataset, rownames must be variables
#' @param nfolds number of points of analysis to do to optimise marker lenghts
#' @param var1 Variable to use for input variable sorting can be  n_pvalue_cutoff, n_increase, n_decrease, ratio, n_increase_pfilt, n_decrease_pfilt, ratio_pfilt, mean_fold, mean_fold_pfilt, mean_
#' @param var2 = Second variable to sort input variables
#' @param sens_class variable to use to classify variables as a marker of sensitivity or resistance (require negative values) e.g mean_fold and ratio
#' @param computational_load proportion of cores to use for analysis
#' @param maxmarker_res The maximum number of resistant markers to be considered. If left NULL the total number of resistant markers will be used.
#' @param maxmarker_sens The maximum number of sensitive markers to be considered. If left NULL the total number of sensitive markers will be used.
#' @param graph if True a graph of pvalue spread across marker combinations will be generated
OptimiseMarkers <- function(EMSRoutput,
drug,
df_response,
df_input,
scale_input = F,
nfolds=50,
maxmarker_res = NULL,
maxmarker_sens = NULL,
var1 = "ratio",
var2 = "mean_fold",
sens_class="ratio",
computational_load = NULL,
graph = F){
if("tidyverse" %in% (.packages())==FALSE){library(tidyverse)}
if("foreach" %in% (.packages())==FALSE){library(foreach)}
if("doParallel" %in% (.packages())==FALSE){library(doParallel)}
if("svglite" %in% (.packages())==FALSE){library(svglite)}
if(scale_input == T){
cols <- colnames(df_input)
df_input <- apply(df_input, 1, FUN = function(x){scale(x, center = T, scale = T)}) %>% t() %>% data.frame()
colnames(df_input) <- cols
}
#format response data
df_response <- df_response[RemoveRepeatNo(colnames(df_input)),drug,drop = F]
rownames(df_response) <- colnames(df_input)
#alter pvalues so they increase with significance
EMSRoutput$mean_p <- -log(EMSRoutput$mean_p)
#build dataframe of sensitive markers
df_sens_m <- EMSRoutput[EMSRoutput[,sens_class]>0,]
df_sens_m <- df_sens_m[df_sens_m$ratio > mean(df_sens_m[,var1], na.rm = T),]
df_sens_m <- df_sens_m[order(df_sens_m[,var1], df_sens_m[,var2], decreasing = T),c("Variable",var1,var2)]
#alter resistant fold values so they increase with significance
df_res_m <- EMSRoutput[EMSRoutput[,sens_class]<0,]
df_res_m$ratio <-(df_res_m$ratio)*-(1)
df_res_m$ratio_pfilt <- (df_res_m$ratio_pfilt)*-(1)
df_res_m$mean_fold <-(df_res_m$mean_fold)*-(1)
df_res_m$mean_fold_pfilt <-(df_res_m$mean_fold)*-(1)
#build dataframe of resistant markers
df_res_m <- df_res_m[df_res_m$ratio > mean(df_res_m[,var1], na.rm = T),]
df_res_m <- df_res_m[order(df_res_m[,var1], df_res_m[,var2], decreasing = T),c("Variable",var1,var2)]
#identify testing paramaters for marker lengths
if(is.null(maxmarker_res)){maxmarker_res <- nrow(df_res_m)}
if(is.null(maxmarker_sens)){maxmarker_sens <- nrow(df_sens_m)}
sens_test <- seq(from = 5, to = maxmarker_sens, by = round(maxmarker_sens/nfolds, 0)) #%>% list()
res_test <- seq(from = 5, to = maxmarker_res, by = round(maxmarker_res/nfolds,0)) #%>% list()
print("generating markers lists")
#generate list of markers using lengths of sens_test and res_test
sens_markers <- sapply(sens_test, FUN = function(x){paste(df_sens_m[1:x, "Variable"], collapse = "-")}) %>% data.frame(stringsAsFactors = F)
res_markers <- sapply(res_test, FUN = function(x){paste(df_res_m[1:x, "Variable"], collapse = "-")}) %>% data.frame(stringsAsFactors = F)
#build tuning grid for foreachfunction
grid <- expand.grid(1:nrow(sens_markers), 1:nrow(res_markers))
#Internal function for generating marker distances
.GetDistances <- function(i){
x <- grid[i,"Var1"]
y <- grid[i,"Var2"]
sens_m <- sens_markers[x,] %>% strsplit("-") %>% unlist()
res_m <- res_markers[y,] %>% strsplit("-") %>% unlist()
sens <- df_input[sens_m,]
s_med <- apply(sens, 2, FUN = function(x)(median(x, na.rm = T)))
s_q3 <- apply(sens, 2, FUN = function(x)(quantile(x, probs = 0.75, na.rm = T)))
res <- df_input[res_m,]
r_med <- apply(res, 2, FUN = function(x)(median(x, na.rm = T)))
r_q3 <- apply(res, 2, FUN = function(x)(quantile(x, probs = 0.75, na.rm = T)))
D <- data.frame((s_med - r_med)+(s_q3 - r_q3))
colnames(D) <- i
return(D)
}
#Internal function of analysing marker distance correlations with drug sensitivity
.SpearmanMarkerAnalysis <- function(i){
df_d <- df_dist[,i, drop = F]
df <- merge.data.frame(df_d, df_response, by = "row.names")
colnames(df) <- c("cells", "D", "AAC")
cc <- cor.test(df$D,df$AAC,method = "spearman", complete.cases=TRUE)
out <- data.frame("pvalue" = cc$p.value,"estimate" = cc$estimate)
out$rep <- c(1:nrow(out))
return(out)
}
if(is.null(computational_load)){
#get distances using marker lists on one core
df_dist <- foreach(i = rownames(grid),
.inorder = T,
.combine = "cbind",
.packages = "dplyr")%do%{
out <- .GetDistances(i) %>% data.frame(stringsAsFactors = F)
print(paste("Distances complete for comparison: ", i,"/", nrow(grid), sep = ""))
return(out)
}
print("begining spearman correlation analysis of marker groups")
#analyse correlation between distances and drug sensitivity using spearman ranking on multiple cores
marker_analysis <- foreach(i = 1:ncol(df_dist),
.inorder = T,
.combine = "rbind",
.packages = c("dplyr"))%do%{
out <- .SpearmanMarkerAnalysis(i)
print(paste("Spearman analysis complete for comparison: ", i,"/", ncol(df_dist), sep = ""))
return(out)
}
}else{
#active relevant cores
cores <- round((computational_load * parallel::detectCores()), 0)
registerDoParallel(cores = cores)
print(paste("running on", cores, "cores"))
print("calculating distances")
#get distances using marker lists on multiple cores
df_dist <- foreach(i = rownames(grid),
.combine = "cbind",
.inorder = T,
.packages = "dplyr")%dopar%{
out <- .GetDistances(i) %>% data.frame(stringsAsFactors = F)
return(out)
}
print("begining spearman correlation analysis of marker groups")
#analyse correlation between distances and drug sensitivity using spearman ranking on multiple cores
marker_analysis <- foreach(i = 1:ncol(df_dist),
.combine = "rbind",
.inorder = T,
.packages = c("dplyr"))%do%{
out <- .SpearmanMarkerAnalysis(i)
}
doParallel::stopImplicitCluster()
}
#get numbers of markers used for each comparison
marker_analysis$rep <- 1:nrow(marker_analysis)
marker_analysis$n_sens <- lapply(marker_analysis$rep, FUN = function(x){sens_test[grid[x, "Var1"]]})%>% unlist() %>% as.double()
marker_analysis$n_res <- lapply(marker_analysis$rep, FUN = function(x){res_test[grid[x, "Var2"]]})%>% unlist()%>% as.double()
if(graph == T){
#Generate pdf of pvalue distribution across variable combinations
pp <- ggplot(marker_analysis, aes(x = n_res, y = n_sens, col = -log(pvalue)))+
scale_color_gradient(low="white", high = "red")+
geom_point(size=2, shape = "square")+
xlab("Resistant marker length")+
ylab("Sensitive marker length")+
theme_classic()
ggsave(plot = pp, filename = paste(var1, "and", var2, "filtered", drug, "markers.pdf", sep = "_"),
device = "pdf",
units = "cm",
dpi = 800,
height = 20, width = 20)
}
#identify optimal marker length combination
optimal <- marker_analysis[marker_analysis$pvalue == min(marker_analysis$pvalue),]
#if multiple combinations generate optimal marker combinations use the one with the fewest total markers
if(nrow(optimal)>1){
tot <- optimal$n_sens+optimal$n_res
optimal <- optimal[tot%in%min(tot),]
}
#generate marker output
print("analysis complete")
out <- data.frame("drug" = drug,
"m_sens" = optimal$n_sens,
"m_res" = optimal$n_res,
"senstive" = sens_markers[grid[optimal$rep, "Var1"],],
"resistant" = res_markers[grid[optimal$rep, "Var2"],],
"var1" = var1,
"var2" = var2,
"class_seperator" = sens_class)
return(out)
}
# roxygen description
#' @title Update Internal Databases for KSEA
#' @name RemoveRepeatNo
#' @usage  RemoveRepeatNo(colnames(df_input))
#' @export RemoveRepeatNo
#' @description Removes the repeat numbers for triplicate data so that datasets can be filtered by cell name
#' @param repeatseperator The string which separates cell name from repeat number. For DRUML data "__" is used as default.
RemoveRepeatNo <- function(x, repeatseperator ="__"){
if("dplyr" %in% (.packages())==FALSE){library(dplyr)}
out <- lapply(x, FUN = function(x){strsplit(x, repeatseperator)[[1]][[1]]})%>% unlist()
return(out)
}
# roxygen description
#' @title Update Internal Databases for KSEA
#' @name Update_databases
#' @usage  Update_databases()
#' @description Update databases from databases files folder
Update_Databases <- function(Inputdir="Input_data"){
require("dplyr")
require("readxl")
#Input Databases
.LoadDatabase<- function(database){
path <- paste(Inputdir,"/",database ,sep ="/")
file_type <- substr(database, start = nchar(database)-3, stop = nchar(database))
if(file_type == "xlsx"){
db <- readxl::read_excel(path=path, sheet="ppIndex")%>% data.frame(row.names = 1, stringsAsFactors = F)
}else if(file_type==".csv"){
db <- read.csv(file = path, stringsAsFactors = F) %>% data.frame(row.names = 1, stringsAsFactors = F)
}
return(db)
}
files <- list.files(Inputdir)
DRUMLphos <- .LoadDatabase(files[2])
DRUMLprot <- .LoadDatabase(files[3])
DRUMLprot <- DRUMLprot[, !colnames(DRUMLprot)%in%c("N.A",	"Name",	"Accessions",	"Mascot.Score",	"No.Unique.Peptides",	"No.Pept.Identifications")]
DRUMLaac <- .LoadDatabase(files[4]) %>% t() %>% data.frame(stringsAsFactors = F)
DRUMLdruginfo <- .LoadDatabase(files[5])
DRUMLcellinfo <- .LoadDatabase(files[6])
#Marker Databases
.ReadMarker <-function(sheet){
path = paste(Inputdir, files[7], sep = "/")
out <- readxl::read_excel(path = path, sheet = sheet) %>% data.frame(stringsAsFactors = F, row.names = 1)
return(out)
}
phospho_aml_markers <- .ReadMarker("phospho aml")
phospho_solid_markers <- .ReadMarker("phospho solid")
prot_aml_markers <- .ReadMarker("prot aml")
prot_solid_markers <- .ReadMarker("prot solid")
rna_aml_markers <- .ReadMarker("rna aml")
rna_solid_markers <- .ReadMarker("rna solid")
usethis::use_data(phospho_aml_markers,
phospho_solid_markers,
prot_aml_markers,
prot_solid_markers,
rna_aml_markers,
rna_solid_markers,
DRUMLaac,
DRUMLphos,
DRUMLprot,
DRUMLcellinfo,
DRUMLdruginfo,
internal = T,
overwrite = T,
compress = "xz")
print("all databases updated")
}
install.packages(c("lubridate", "promises", "systemfonts"))
